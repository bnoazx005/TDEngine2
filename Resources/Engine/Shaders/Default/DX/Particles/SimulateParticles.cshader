#define COMPUTE_ENTRY MainCS

#program compute

#include <TDEngine2Globals.inc>
#include <TDEngine2MathUtils.inc>
#include <TDEngine2ParticlesUtils.inc>


DECLARE_WRITEABLE_TYPED_BUFFER_EX(TParticle, OutputParticles, 0);
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, DeadParticlesIndexList, 1); // first index is used for counter
DECLARE_WRITEABLE_TYPED_BUFFER_EX(float2, ParticlesIndexBuffer, 2); 
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, Counters, 3); 
RWBuffer<uint> DrawArgsBuffer : register(u4);

DECLARE_TEX2D_EX(EmittersCurvesAtlasTexture, 1)
DECLARE_TEX2D_EX(RandTexture, 2)


CBUFFER_SECTION_EX(SimulationParameters, 4)
	float4 mCameraPosition;
	float  mDeltaTime; // global CBs(UBOs) are not available at this execution time yet so use separate members for time
	uint   mMaxParticlesCount;
	float2 mPadding0;
CBUFFER_ENDSECTION


[numthreads(256, 1, 1)]
void MainCS(uint3 id : SV_DispatchThreadID)
{
	if (id.x == 0) // initialization of draw args buffer
	{
		DrawArgsBuffer[0] = 6;
		DrawArgsBuffer[1] = 0;
		DrawArgsBuffer[2] = 0;
		DrawArgsBuffer[3] = 0;
		DrawArgsBuffer[4] = 0;

		Counters[0] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	if (id.x >= mMaxParticlesCount)
		return;

	TParticle currParticle = OutputParticles[id.x];
	if (currParticle.mLifeParamsAndRotationPerFrame.x > 0.0)
	{
		float t = 1.0 - saturate(currParticle.mLifeParamsAndRotationPerFrame.x / currParticle.mLifeParamsAndRotationPerFrame.y);

		float4 velocitySizeCurve = EmittersCurvesAtlasTexture.Load(int4((float2)currParticle.mEmitterParams.xy + float2(128.0 * t, 0.0), 0, 0));

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_SIZE_OVER_LIFETIME_ENABLED)
		{
			currParticle.mPositionAndSize.w = velocitySizeCurve.a;
		}

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_COLOR_OVER_LIFETIME_ENABLED)
		{
			float4 randValue = TEX2D_LOD(RandTexture, float2(id.x / 1024.0, 0.0), 0);

			if (currParticle.mEmitterParams.z & PARTICLE_FLAG_USE_COLOR_RANDOM_TWEEN)
				t = randValue.x;

			currParticle.mColor = EmittersCurvesAtlasTexture.Load(int4((float2)currParticle.mEmitterParams.xy + float2(128.0 * t, 1.0), 0, 0));
		}

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_ROTATION_OVER_LIFETIME_ENABLED)
		{
			currParticle.mVelocityAndRotation.w += mDeltaTime * currParticle.mLifeParamsAndRotationPerFrame.z;
		}

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_VELOCITY_OVER_LIFETIME_ENABLED)
		{
			currParticle.mVelocityAndRotation.xyz = velocitySizeCurve.xyz;
		}

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_GRAVITY_FORCE_ENABLED)
		{
			currParticle.mVelocityAndRotation.xyz += float3(0.0, -currParticle.mForcePerFrameAndGravityModifier.w, 0.0);
		}

		if (currParticle.mEmitterParams.z & PARTICLE_FLAG_FORCE_OVER_LIFETIME_ENABLED)
		{
			currParticle.mVelocityAndRotation.xyz += currParticle.mForcePerFrameAndGravityModifier.xyz;
		}

		currParticle.mLifeParamsAndRotationPerFrame.x -= mDeltaTime;
		currParticle.mPositionAndSize.xyz += currParticle.mVelocityAndRotation.xyz * mDeltaTime;

		if (currParticle.mLifeParamsAndRotationPerFrame.x < 0.0f)
		{
			currParticle.mLifeParamsAndRotationPerFrame.x = -1.0;

			// write index to dead list
			int deadListIndex = 0;
			InterlockedAdd(Counters[1], 1, deadListIndex);
			DeadParticlesIndexList[deadListIndex] = id.x;
		}
		else
		{
			// add particle to index buffer for sorting
			int aliveIndex = 0;
			InterlockedAdd(Counters[0], 1, aliveIndex);

			ParticlesIndexBuffer[aliveIndex] = float2(length(mCameraPosition - float4(currParticle.mPositionAndSize.xyz, 1.0)), (float)id.x);

			// update indirect args buffer
			InterlockedAdd(DrawArgsBuffer[1], 1);
		}
	}	

	OutputParticles[id.x] = currParticle;
}

#endprogram
