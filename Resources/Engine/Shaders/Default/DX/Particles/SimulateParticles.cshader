#define COMPUTE_ENTRY MainCS

#program compute

#include <TDEngine2Globals.inc>
#include <TDEngine2MathUtils.inc>
#include <TDEngine2ParticlesUtils.inc>


DECLARE_WRITEABLE_TYPED_BUFFER_EX(TParticle, OutputParticles, 0);
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, DeadParticlesIndexList, 1); // first index is used for counter
DECLARE_WRITEABLE_TYPED_BUFFER_EX(float2, ParticlesIndexBuffer, 2); 
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, Counters, 3); 
RWBuffer<uint> DrawArgsBuffer : register(u4);


CBUFFER_SECTION_EX(SimulationParameters, 4)
	float mDeltaTime; // global CBs(UBOs) are not available at this execution time yet so use separate members for time
	uint  mMaxParticlesCount;
CBUFFER_ENDSECTION


[numthreads(256, 1, 1)]
void MainCS(uint3 id : SV_DispatchThreadID)
{
	if (id.x == 0) // initialization of draw args buffer
	{
		DrawArgsBuffer[0] = 0;
		DrawArgsBuffer[1] = 1;
		DrawArgsBuffer[2] = 0;
		DrawArgsBuffer[3] = 0;
		DrawArgsBuffer[4] = 0;

		Counters[1] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	if (id.x >= mMaxParticlesCount)
		return;

	TParticle currParticle = OutputParticles[id.x];
	if (currParticle.mAge > 0.0)
	{
		currParticle.mAge -= mDeltaTime;
		currParticle.mPosition += currParticle.mVelocity * mDeltaTime;

		/*

struct TParticle
{
	float4 mPosition;
	float4 mVelocity;
	float4 mColor;
	float mAge;
	float mLifetime;
	float mRotation;
	float mSize;
	uint  mEmitterIndex;
	uint3 mPadding0;
};

*/
		if (currParticle.mAge < 0.0f)
		{
			currParticle.mAge = -1.0;

			// write index to dead list
			int deadListIndex = 0;
			InterlockedAdd(Counters[0], 1, deadListIndex);
			DeadParticlesIndexList[deadListIndex] = id.x;
		}
		else
		{
			// add particle to index buffer for sorting
			int aliveIndex = 0;
			InterlockedAdd(Counters[1], 1, aliveIndex);

			ParticlesIndexBuffer[aliveIndex] = float2(0.0 /* distance to camera's origin */, (float)id.x);

			// update indirect args buffer
			InterlockedAdd(DrawArgsBuffer[0], 6);
		}
	}	

	OutputParticles[id.x] = currParticle;
}

#endprogram
