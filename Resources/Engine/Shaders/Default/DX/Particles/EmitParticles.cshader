#define COMPUTE_ENTRY MainCS

#program compute

#include <TDEngine2Globals.inc>
#include <TDEngine2MathUtils.inc>
#include <TDEngine2ParticlesUtils.inc>


DECLARE_WRITEABLE_TYPED_BUFFER_EX(TParticle, OutputParticles, 0);
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, DeadParticlesIndexList, 1); 
DECLARE_WRITEABLE_TYPED_BUFFER_EX(uint, Counters, 2); 

DECLARE_TEX2D_EX(RandTexture, 1)
DECLARE_TEX2D_EX(EmittersCurvesAtlasTexture, 2)

// particles buffer

// emitter's configuration
CBUFFER_SECTION_EX(EmitterParameters, 4)
	// box emitter's data
	float4 mBoxSizes;

	// sphere/cone emitter's data
	float  mSphereConeRadius;
	float  mConeHeight;
	float  mRngSalt;

	// common 
	float  mDuration;
	float4 mPosition;
	float4 mShapeOrigin;
	float4 mVelocity;
	float4 mInitialLifetime; // x - left bound, y - right bound, value lies in range of [x; y] 
	float4 mInitialSize; // x - left bound, y - right bound, value lies in range of [x; y] 
	float4 mInitialRotation;
	float4 mInitialColor;

	uint   mIs2DEmitter;
	uint   mMaxParticles;
	uint   mEmitRate;
	uint   mEmitterType;
	uint   mEmitterIndex;
	uint   mFlags;
	float  mGravityModifier;
	float  mRotationPerFrame;
	float3 mForcePerFrame;
	float  mPadding0;

	int2   mEmittersAtlasStartPos;
CBUFFER_ENDSECTION


[numthreads(1024, 1, 1)]
void MainCS(uint3 id : SV_DispatchThreadID)
{
	uint counter = Counters[1];

	if (id.x >= counter || id.x >= mEmitRate) 
		return;

	TParticle newParticle = (TParticle)0;

	float4 randValue = TEX2D_LOD(RandTexture, float2(id.x / 1024.0, mRngSalt), 0);
	float4 randValue1 = TEX2D_LOD(RandTexture, float2((id.x + 1.0) / 1024.0, mRngSalt), 0);

	newParticle.mEmitterIndex = mEmitterIndex;
	newParticle.mEmittersAtlasStartPos = mEmittersAtlasStartPos;

	if (mEmitterType == BOX_EMITTER_TYPE_ID)
	{
		newParticle.mPosition = GeneratePositionForBoxEmitter(mPosition, mShapeOrigin, mBoxSizes, randValue1);
	}
	else if (mEmitterType == SPHERE_EMITTER_TYPE_ID)
	{
		newParticle.mPosition = GeneratePositionForSphereEmitter(mPosition, mShapeOrigin, mSphereConeRadius, randValue1);
	}
	else if (mEmitterType == CONE_EMITTER_TYPE_ID)
	{
		newParticle.mPosition = GeneratePositionForConeEmitter(mPosition, mShapeOrigin, mSphereConeRadius, mConeHeight, randValue1);	
	}

	newParticle.mVelocity = mVelocity;

	newParticle.mRotation = lerp(mInitialRotation.x, mInitialRotation.y, randValue.x);

	newParticle.mColor = mInitialColor;

	newParticle.mLifetime = lerp(mInitialLifetime.x, mInitialLifetime.y, randValue.y);
	newParticle.mAge      = newParticle.mLifetime;

	// emmiter's data 
	newParticle.mEmitterFlags     = mFlags;
	newParticle.mGravityModifier  = mGravityModifier;
	newParticle.mRotationPerFrame = mRotationPerFrame;
	newParticle.mForcePerFrame    = mForcePerFrame;

	newParticle.mSize = lerp(mInitialSize.x, mInitialSize.y, randValue.z);

	// decrement counter for dead particles list
	InterlockedAdd(Counters[1], -1, counter);
	counter = counter - 1;
	if (counter < 0)
	{
		InterlockedAdd(Counters[1], 1);
		return;
	}

	uint index = DeadParticlesIndexList[counter];

	OutputParticles[index] = newParticle;
}

#endprogram
