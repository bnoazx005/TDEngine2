#define COMPUTE_ENTRY MainCS

#program compute

#include <TDEngine2Globals.inc>
#include <TDEngine2MathUtils.inc>


RWTexture2D<float4> OutputTexture;
DECLARE_TEX2D_EX(DepthTexture, 1);
DECLARE_TEX3D_EX(LowFreqCloudsNoiseTex, 2);
DECLARE_TEX3D_EX(HiFreqCloudsNoiseTex, 3);
DECLARE_TEX2D_EX(WeatherMap, 4);


CBUFFER_SECTION_EX(RenderParameters, 4)
	float2 mInvTextureSize;
	int    mStepsCount;
CBUFFER_ENDSECTION


CBUFFER_SECTION_EX(CloudsParameters, 5)
	float4 mAtmosphereParameters; // x - Earth radius, y - atmosphere inner radius, z - atmosphere thickness
	float4 mWindParameters; // xy - direction, w - scale factor
	float  mCoverage;
	float  mCurliness;
	float  mCrispiness;
CBUFFER_ENDSECTION


float GetHeightFraction(float3 pos)
{
	float innerAtmosphereRadius = mAtmosphereParameters.x  + mAtmosphereParameters.y;
	float outerAtmosphereRadius = innerAtmosphereRadius + mAtmosphereParameters.z;

    return (length(pos - float3(0.0, -mAtmosphereParameters.x, 0.0)) - innerAtmosphereRadius) / (outerAtmosphereRadius - innerAtmosphereRadius);
}


float2 GetUVProjection(float3 p)
{
    float innerRadius = mAtmosphereParameters.x + mAtmosphereParameters.y;
    return p.xz / innerRadius + 0.5f;
}


// Cloud types height density gradients
static const float4 STRATUS_GRADIENT       = float4(0.0, 0.1, 0.2, 0.3);
static const float4 STRATOCUMULUS_GRADIENT = float4(0.02, 0.2, 0.48, 0.625);
static const float4 CUMULUS_GRADIENT       = float4(0.0, 0.1625, 0.88, 0.98);


static const float3 FBM_COEFFS = float3(0.625, 0.25, 0.125);


float GetDensityForCloud(float heightFraction, float cloudType)
{
    float stratusFactor = 1.0 - clamp(cloudType * 2.0, 0.0, 1.0);
    float stratoCumulusFactor = 1.0 - abs(cloudType - 0.5) * 2.0;
    float cumulusFactor = clamp(cloudType - 0.5, 0.0, 1.0) * 2.0;

    float4 baseGradient = stratusFactor * STRATUS_GRADIENT + stratoCumulusFactor * STRATOCUMULUS_GRADIENT + cumulusFactor * CUMULUS_GRADIENT;
    return smoothstep(baseGradient.x, baseGradient.y, heightFraction) - smoothstep(baseGradient.z, baseGradient.w, heightFraction);
}


float SampleCloudDensity(float3 pos, bool applyHiFreqNoise = true)
{
	float heightFraction = GetHeightFraction(pos) + 1e-2;

	float2 uv = GetUVProjection(pos);
	float2 scrolledUV = GetUVProjection(pos + float3((heightFraction * 750.0f + mWindParameters.w * Time.x) * mWindParameters.xy, 0.0));

    if (heightFraction < 1e-3 || heightFraction > 1.0)
        return 0.0f;

	float4 lowFreqNoises = TEX3D_LOD(LowFreqCloudsNoiseTex, float3(uv * mCrispiness, heightFraction), 0);

	float lowFreqFBM = dot(lowFreqNoises.gba, FBM_COEFFS);
    float cloudSample = Remap(lowFreqNoises.r, -(1.0f - lowFreqFBM), 1.0, 0.0, 1.0);

    float4 weatherData = TEX2D_LOD(WeatherMap, scrolledUV, 0);

	float density = GetDensityForCloud(heightFraction, weatherData.y);
    cloudSample *= (density / heightFraction);

    float cloudWeatherCoverage = weatherData.x * mCoverage;

    float cloudSampleWithCoverage = Remap(cloudSample, cloudWeatherCoverage, 1.0f, 0.0f, 1.0f);
    cloudSampleWithCoverage *= cloudWeatherCoverage;

    // high freq noise application
    if (applyHiFreqNoise)
    {
    	float3 highFreqNoise = TEX3D_LOD(HiFreqCloudsNoiseTex, float3(scrolledUV * mCrispiness, heightFraction) * mCurliness, 0).rgb;
    	float highFreqFBM = dot(highFreqNoise.rgb, FBM_COEFFS);    
    	float highFreqNoiseModifier = lerp(highFreqFBM, 1.0f - highFreqFBM, clamp(heightFraction * 10.0f, 0.0f, 1.0f));
    	cloudSampleWithCoverage = cloudSampleWithCoverage - highFreqNoiseModifier * (1.0 - cloudSampleWithCoverage);
    	cloudSampleWithCoverage = Remap(cloudSampleWithCoverage * 2.0, highFreqNoiseModifier * 0.2, 1.0f, 0.0f, 1.0f);
    }

	return saturate(cloudSampleWithCoverage);
}


float DoRayMarchToSun(float3 pos, float stepSize)
{
	int StepsCount = 8;

    float deltaStep = stepSize * (float)StepsCount;
	float3 dirStep = SunLightDirection.xyz * deltaStep;

	float transmitance = 1.0; // transmitance
    float density = 0.0;
    float sigmaDeltaStep = -deltaStep * 0.03;

	for (int i = 0; i < StepsCount; i++) 
	{
        float heightFraction = GetHeightFraction(pos);
        if (heightFraction > 0)
        {        	
            float cloudDensity = SampleCloudDensity(pos);
            if (cloudDensity > 0.0)
            {
                float currTransmittance = exp(cloudDensity * sigmaDeltaStep);
                transmitance *= currTransmittance;
                density += cloudDensity;
            }
        }

		pos += dirStep;
	}

	return transmitance;
}



float4 DoRayMarchToCloud(Ray3 ray, float3 earthCenter, float2 intersectionsParams)
{
	float thickness = intersectionsParams.y - intersectionsParams.x;
	float stepSize = thickness / (float)mStepsCount;

	float3 color = float3(0.0, 0.0, 0.0);
	float alpha = 0.0;

	float transmitance = 1.0;
    float sigmaDeltaStep = -stepSize * 0.01;

	int i = 0;

	//float h = SampleCloudDensity(ray.origin + intersectionsParams.x * ray.dir);
	//return float4(h, h, h, h);

	for (float t = intersectionsParams.x; t < intersectionsParams.y; t += stepSize)
	{
		float3 pos = ray.origin + t * ray.dir;

		float densitySample = SampleCloudDensity(pos);
		if (densitySample > 0.0)
		{
            float deltaTransmittance = exp(densitySample * sigmaDeltaStep);
            float3 Sint =  deltaTransmittance * (1.0f / densitySample);
            color.rgb += transmitance * Sint;
            transmitance *= deltaTransmittance;
		}
	}

	return float4(color * 0.05, 1.0 - transmitance);//TODO temp fix
}


[numthreads(16, 16, 1)]
void MainCS(uint3 id : SV_DispatchThreadID)
{
	float2 uv = id.xy * mInvTextureSize; // thread id to [0; 1]
	uv.x = 2.0 * uv.x - 1.0;
	uv.y = 1.0 - 2.0 * uv.y;

	float4 viewDir = normalize(mul(InvViewMat, float4(mul(InvProjMat, float4(uv, 0.0, 1.0)).xyz, 0.0)));
	Ray3 primaryRay = MakeRay(CameraPosition.xyz, float3(viewDir.xyz));

	if (TEX2D_LOD(DepthTexture, id.xy * mInvTextureSize, 0).r < 0.999 || dot(primaryRay.dir, float3(0.0, 1.0, 0.0)) < 1e-3)
	{
		OutputTexture[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
		return;
	}

	float3 earthCenter = float3(0.0, -mAtmosphereParameters.x, 0.0);

	float innerAtmosphereRadius = mAtmosphereParameters.x  + mAtmosphereParameters.y;
	float outerAtmosphereRadius = innerAtmosphereRadius + mAtmosphereParameters.z;

	float startT = IntersectRaySphere(primaryRay, float4(float3(CameraPosition.x, -mAtmosphereParameters.x, CameraPosition.z), innerAtmosphereRadius));
	float endT = IntersectRaySphere(primaryRay, float4(float3(CameraPosition.x, -mAtmosphereParameters.x, CameraPosition.z), outerAtmosphereRadius));

	OutputTexture[id.xy] = DoRayMarchToCloud(primaryRay, earthCenter, float2(startT, endT));

/*
	float3 pos = startPos;
	
	float3 color = float3(0.0, 0.0, 0.0);
	float alpha = 0.0;

	float transmitance = 1.0;

	for (int i = 0; i < mStepsCount; i++)
	{
		float density = TEX3D_LOD(LowFreqCloudsNoiseTex, pos / 200.0, 0).r;
		density *= smoothstep(0.5, 0.505, density);
		density = saturate(density);

		float h = (float)i/(float)mStepsCount;

		float T_i = exp(-1.030725 * density * stepSize);
		transmitance *= T_i;

		if (T_i < 0.01) break;

		color += transmitance * (exp(h) / 1.75) * stepSize * density;
		alpha += (1. - T_i) * (1. - alpha);

		pos += primaryRay.dir * stepSize;
	}

	OutputTexture[id.xy] = float4(color, alpha);*/
}

#endprogram
